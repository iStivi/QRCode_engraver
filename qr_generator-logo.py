import os, qrcode

######################################
#input address to be made into Qr code
######################################

#qrstring = "133Gf5WZEJpNN77upypUGGHZU8pW3oui1c"  #my bitcoin coinjar
#qrstring = "141GrJnezKmcF7WBXD53szdyJ4ehuFHASK" #my bitcoin blockchain
#qrstring = "DLvCt97Hg7Aia8fdkQt8ZGs9wjDDGygGYW" #my doge
qrstring = "1ZUWgvPfNskFv3CeWUfE4QRHwTVsoiu9o" #my coinjar

#########################
##Machining parameters
#########################

#coin logo type to be engraved
pretext = "30mm-My-coinjar" #pre-text for start of filename
coin_type = "bitcoin"
#coin_type = "doge"
#coin_type = "litecoin"

#input files
bitcoin_logo_file = "bitcoin_logo.txt" #file for cutting logo in centre

#name of G-code file to be output
output_path = "output"
output_file = output_path + "/" + pretext + "_" + coin_type + "_qr_engrave.nc"

if not os.path.exists(output_path):
    os.makedirs(output_path)

#parameters for the engraving process
feed_rate = 200 #mm per second
dwell_time = 0.025 #pause time after plunge in seconds
mill_width = 0.2  #engraver/end mill width (0.1 smaller than actual cutter width gives better results)
tool_number = 1 #number of tool programmed in Mach3. Safe to ignore for manual mounting
engrave_depth = 0.1 #depth of engrave cut in mm
depth_per_pass = 0.1 #depth to cut at a time in mm
clearance_height = 1 #height above stock to make quick moves between cuts in mm
pixel_size = 0.7 #in mm. Version 3 qr code is 29 pixels all sides
border_size = 1 #number of pixels clearance either side of code area, 4 is standard. Minimum of 1
#offsets
#centre image
x_offset = -(( pixel_size ) * ( 29 + 2 * border_size ))/2
y_offset = x_offset
#set manual
#x_offset = -10.85 #0.7mm 4.15 0.8mm 2.6 #left offset of where code appears in mm
#y_offset = -13  #0.7mm 5.5 0.8mm #bottom offset of where code appears in mm
square_size = pixel_size*(29+(border_size*2))
print(square_size, "mm dimensions")

###############################################################
##Start Script
###############################################################

def main():
    #create qrcode data and generate sample png file
    global qr
    qr = qrcode.QRCode(
        version=3,  #version 3 is smallest size bitcoin address will compress to
        error_correction=qrcode.constants.ERROR_CORRECT_M,
        border=border_size,
    )

    qr.add_data(qrstring)
    qr.make()
    img = qr.make_image()
    img.save("qr_view.png")

    numrows = len(qr.get_matrix())
    numcols = len(qr.get_matrix()[0])
    print("rows = ",numrows)
    print("columns = ",numcols)

    #make new matrix
    
    global qrmatrix
    qrmatrix = [[True for x in range(numrows)]for x in range(numcols)]

    for i in range(numrows):
        for j in range (numcols):
            qrmatrix[i][j]=qr.get_matrix()[i][j]
    print(qrmatrix) 

    if coin_type == "bitcoin":
        for i in range(11, 19):
            for j in range (12,18):
                qrmatrix[i][j]=False

    global check_array
    check_array = [[False]*numcols for _ in range(numrows)]
    global check_island_array
    check_island_array = [[False]*numcols for _ in range(numrows)]
    global island_array
    island_array = [[True]*numcols for _ in range(numrows)]

    build_island_array()
            
    #Write header data to Gcode and set up machine
    print(output_file)
    
    gcode_out = open(output_file,'w')
    gcode_out.write("% QR Code Engraving script for " + coin_type + " \n")
    gcode_out.write("% Code formatted for compatibility with Mach3 \n")
    gcode_out.write("% Generated by qr_generator.py https://github.com/iStivi/QRCode_engraver \n")
    gcode_out.write("% Engraving coded string: " + qrstring + " \n") 
    gcode_out.write("G21 G90\n") #metric, absolute coords

    gcode_out.write("T%(a)s M6 ( %(b)smm engraving tool )\n" % {'a': tool_number, 'b': mill_width }) 
    


    if coin_type == "bitcoin":
        code_in = open(bitcoin_logo_file,'r')
        gcode_out.write("% Cutting out logo \n")
        for line in code_in:
            gcode_out.write(line)
        gcode_out.write("\n")    

    #write Gcode for marking out the QR code pattern
    gcode_out.write("F" + str(feed_rate) + "\n")
    gcode_out.write("M3 \n")
    gcode_out.write("G1 Z" + str(clearance_height) + "\n")
    gcode_out.write("G1 Z" + str(clearance_height) + "\n")
    gcode_out.write("% Cutting out QR code \n")
    

    ###################
    ##cut outline paths
    ###################
    gcode_out.write("% Cutting paths ****************** \n")
    for y, line in enumerate(qrmatrix):
        for x, point in enumerate(line):
            if point == False:
                continue
            elif check_array[x][y] == False:
                cut_path(gcode_out, x, y)
                pass

    #########################################
    ##use outline_array to cut around islands
    #########################################
    gcode_out.write("% Cutting islands **************** \n")
    for y in range(0,len(island_array)):
        for x in range(0,len(island_array)):
            if island_array[x][y] == False:
                continue
            else:
                if check_island_array[x][y] == False:
                    cut_island(gcode_out, x, y)
                    
    ###############################
    ##cut out material inside paths
    ###############################

    ##need to refresh check_array first
    check_array = [[False]*numcols for _ in range(numrows)]
    gcode_out.write("% Cutting fills ****************** \n")                
    for y, line in enumerate(qrmatrix):
        for x, point in enumerate(line):
            if point == False:
                continue
            elif check_array[x][y] == False:
                cut_horizontal(gcode_out,x,y)
                pass
                    
    gcode_out.write("M30 \n")
    gcode_out.close()



##########################################################################
## End of main
##########################################################################

    

########################
## Cut out islands
########################
        
def cut_island(gcode_out, x, y ):
    #Cut out following top path starting from top left corner 
    start_x = x
    start_y = y
    x_path = [start_x]
    y_path = [start_y]
    start_direction = 1
    move_x = start_x
    move_y = start_y

    #check if pixel not already in middle of paths
    if check_island_array[move_x][move_y+1] == True:
        check_island_array[move_x][move_y] = True
        return
    elif check_island_array[move_x][move_y-1] == True:
        check_island_array[move_x][move_y] = True
        return
    elif check_island_array[move_x+1][move_y] == True:
        check_island_array[move_x][move_y] = True
        return
    elif check_island_array[move_x-1][move_y] == True:
        check_island_array[move_x][move_y] = True
        return

        
    #move directions 1=right,2=down,3=left,4=up
    #take pixel check all 4 directions
    #####check starting direction
    #check starting direction
    if island_array[start_x][start_y-1] == True:
        start_direction = 4
        move_y = start_y-1
    elif island_array[start_x + 1][start_y] == True:
        start_direction = 1
        move_x = start_x + 1
    elif island_array[start_x][start_y + 1] == True:
        start_direction = 2
        move_y = start_y + 1
    elif island_array[start_x - 1][start_y] == True:
        start_direction = 3
        move_x = start_x - 1
    dir_path=[start_direction]
    direction=start_direction
    continue_path = True
    while continue_path == True:
        check_island_array[move_x][move_y] = True   #check off already done pixels
        if (move_x==start_x) and (move_y==start_y) and (direction==start_direction):
                    continue_path = False
                    continue
        if direction==1:   #moving right   
            #check up
            test_x = move_x
            test_y = move_y - 1
            test_pixel = island_array[test_x][test_y]
            if test_pixel==True:
                direction=4
                x_path.append(move_x)
                y_path.append(move_y)
                dir_path.append(4)
                if (move_x==start_x) and (move_y==start_y) and (direction==start_direction):
                    continue_path = False
                move_y = move_y - 1
                continue
            #move right 1
            test_x = move_x + 1
            test_y = move_y
            test_pixel = island_array[test_x][test_y]
            if test_pixel==True:
                move_x = move_x + 1
                if (move_x==start_x) and (move_y==start_y) and (direction==start_direction):
                    continue_path = False
                continue
            #check down
            test_x = move_x
            test_y = move_y + 1
            test_pixel = island_array[test_x][test_y]
            if test_pixel==True:
                direction=2
                x_path.append(move_x)
                y_path.append(move_y)
                dir_path.append(2)
                if (move_x==start_x) and (move_y==start_y) and (direction==start_direction):
                    continue_path = False
                move_y = move_y + 1
                continue
            #check left
            test_x = move_x - 1
            test_y = move_y
            test_pixel = island_array[test_x][test_y]
            if test_pixel==True:
                direction=3
                x_path.append(move_x)
                y_path.append(move_y)
                dir_path.append(2)
                x_path.append(move_x)
                y_path.append(move_y)
                dir_path.append(3)
                if (move_x==start_x) and (move_y==start_y) and (direction==start_direction):
                    continue_path = False
                move_x = move_x - 1
                continue
        elif direction==2:  #moving down
            #check right
            test_x = move_x + 1
            test_y = move_y
            test_pixel = island_array[test_x][test_y]
            if test_pixel==True:
                direction=1
                x_path.append(move_x)
                y_path.append(move_y)
                dir_path.append(1)
                if (move_x==start_x) and (move_y==start_y) and (direction==start_direction):
                    continue_path = False
                move_x = move_x + 1
                continue
            #move down 1
            test_x = move_x
            test_y = move_y + 1
            test_pixel = island_array[test_x][test_y]
            if test_pixel==True:
                move_y = move_y + 1
                if (move_x==start_x) and (move_y==start_y) and (direction==start_direction):
                    continue_path = False
                continue
            #check left
            test_x = move_x - 1
            test_y = move_y
            test_pixel = island_array[test_x][test_y]
            if test_pixel==True:
                direction=3
                x_path.append(move_x)
                y_path.append(move_y)
                dir_path.append(3)
                if (move_x==start_x) and (move_y==start_y) and (direction==start_direction):
                    continue_path = False
                move_x = move_x - 1
                continue
            #check up
            test_x = move_x
            test_y = move_y - 1
            test_pixel = island_array[test_x][test_y]
            if test_pixel==True:
                direction=4
                x_path.append(move_x)
                y_path.append(move_y)
                dir_path.append(3)
                x_path.append(move_x)
                y_path.append(move_y)
                dir_path.append(4)
                if (move_x==start_x) and (move_y==start_y) and (direction==start_direction):
                    continue_path = False
                move_y = move_y - 1
                continue
        elif direction == 3:    #move left
            #check down
            test_x = move_x
            test_y = move_y + 1
            test_pixel = island_array[test_x][test_y]
            if test_pixel==True:
                direction=2
                x_path.append(move_x)
                y_path.append(move_y)
                dir_path.append(2)
                if (move_x==start_x) and (move_y==start_y) and (direction==start_direction):
                    continue_path = False
                move_y = move_y + 1
                continue
            #move left 1
            test_x = move_x - 1
            test_y = move_y
            test_pixel = island_array[test_x][test_y]
            if test_pixel==True:
                move_x = move_x - 1
                if (move_x==start_x) and (move_y==start_y) and (direction==start_direction):
                    continue_path = False
                continue
            #check up
            test_x = move_x
            test_y = move_y - 1
            test_pixel = island_array[test_x][test_y]
            if test_pixel==True:
                direction=4
                x_path.append(move_x)
                y_path.append(move_y)
                dir_path.append(4)
                if (move_x==start_x) and (move_y==start_y) and (direction==start_direction):
                    continue_path = False
                move_y = move_y - 1
                continue
            #check right
            test_x = move_x + 1
            test_y = move_y
            test_pixel = island_array[test_x][test_y]
            if test_pixel==True:
                direction=1
                x_path.append(move_x)
                y_path.append(move_y)
                dir_path.append(4)
                x_path.append(move_x)
                y_path.append(move_y)
                dir_path.append(1)
                if (move_x==start_x) and (move_y==start_y) and (direction==start_direction):
                    continue_path = False
                move_x = move_x + 1
                continue
        elif direction == 4: #move up
            #check left
            test_x = move_x - 1
            test_y = move_y
            test_pixel = island_array[test_x][test_y]
            if test_pixel==True:
                direction=3
                x_path.append(move_x)
                y_path.append(move_y)
                dir_path.append(3)
                if (move_x==start_x) and (move_y==start_y) and (direction==start_direction):
                    continue_path = False
                move_x = move_x - 1
                continue
            #move up 1
            test_x = move_x
            test_y = move_y - 1
            test_pixel = island_array[test_x][test_y]
            if test_pixel==True:
                move_y = move_y - 1
                if (move_x==start_x) and (move_y==start_y) and (direction==start_direction):
                    continue_path = False
                continue
            #check right
            test_x = move_x + 1
            test_y = move_y
            test_pixel = island_array[test_x][test_y]
            if test_pixel==True:
                direction=1
                x_path.append(move_x)
                y_path.append(move_y)
                dir_path.append(1)
                if (move_x==start_x) and (move_y==start_y) and (direction==start_direction):
                    continue_path = False
                move_x = move_x + 1
                continue
            #check down
            test_x = move_x
            test_y = move_y + 1
            test_pixel = island_array[test_x][test_y]
            if test_pixel==True:
                direction=2
                x_path.append(move_x)
                y_path.append(move_y)
                dir_path.append(1)
                x_path.append(move_x)
                y_path.append(move_y)
                dir_path.append(2)
                if (move_x==start_x) and (move_y==start_y) and (direction==start_direction):
                    continue_path = False
                move_y = move_y + 1
                continue
    
    ###########################
    ##G-code for cutting island
    ###########################

    #if single pixel do simple cut
    if len(x_path) == 1:
        x_start = (x_path[0] * pixel_size) - mill_width + x_offset
        y_start = square_size - (y_path[0] * pixel_size) + mill_width + y_offset
        x_end = (x_path[0]*pixel_size) + pixel_size + mill_width + x_offset
        y_end = square_size - (y_path[0] * pixel_size) - pixel_size - mill_width + y_offset
        gcode_out.write("G0 X%(x)0.4f Y%(y)0.4f \n" % {'x': x_start, 'y': y_start})
        #cut square
        cut_passes = int(engrave_depth / depth_per_pass)
        for cut_pass in range(0, cut_passes):
            pass_depth = (1 + cut_pass) * depth_per_pass
            gcode_out.write("G1 Z-%0.4f \n" % pass_depth)
            gcode_out.write("G4 P%0.1f \n" % dwell_time)
            gcode_out.write("G1 X%(x)0.4f Y%(y)0.4f \n" % {'x': x_end, 'y': y_start})
            gcode_out.write("G4 P%0.1f \n" % dwell_time)
            gcode_out.write("G1 X%(x)0.4f Y%(y)0.4f \n" % {'x': x_end, 'y': y_end})
            gcode_out.write("G4 P%0.1f \n" % dwell_time)
            gcode_out.write("G1 X%(x)0.4f Y%(y)0.4f \n" % {'x': x_start, 'y': y_end})
            gcode_out.write("G4 P%0.1f \n" % dwell_time)
            gcode_out.write("G1 X%(x)0.4f Y%(y)0.4f \n" % {'x': x_start, 'y': y_start})
            gcode_out.write("G4 P%0.1f \n" % dwell_time)
        if(engrave_depth%depth_per_pass==0):
            pass
        else:
            gcode_out.write("G1 Z-%0.4f \n" % engrave_depth)
            gcode_out.write("G4 P%0.1f \n" % dwell_time)
            gcode_out.write("G1 X%(x)0.4f Y%(y)0.4f \n" % {'x': x_end, 'y': y_start})
            gcode_out.write("G4 P%0.1f \n" % dwell_time)
            gcode_out.write("G1 X%(x)0.4f Y%(y)0.4f \n" % {'x': x_end, 'y': y_end})
            gcode_out.write("G4 P%0.1f \n" % dwell_time)
            gcode_out.write("G1 X%(x)0.4f Y%(y)0.4f \n" % {'x': x_start, 'y': y_end})
            gcode_out.write("G4 P%0.1f \n" % dwell_time)
            gcode_out.write("G1 X%(x)0.4f Y%(y)0.4f \n" % {'x': x_start, 'y': y_start})
            gcode_out.write("G4 P%0.1f \n" % dwell_time)  
    else:
        #start from top pixel and keep going down    
        x_cut = ( x_path[0] * pixel_size ) - mill_width + x_offset
        y_cut = square_size - ( y_path[0] * pixel_size ) + mill_width + y_offset
        #move to start point of path
        gcode_out.write("G0 X%(x)0.4f Y%(y)0.4f \n" % {'x': x_cut, 'y': y_cut})
        cut_passes = int(engrave_depth / depth_per_pass)
        for cut_pass in range(0, cut_passes):
            pass_depth = (1 + cut_pass) * depth_per_pass
            gcode_out.write("G1 Z-%0.4f \n" % pass_depth)
            gcode_out.write("G4 P%0.1f \n" % dwell_time)
            #check if path going straight down first
            if dir_path[0] == 2:
                x_cut = ( x_path[0] * pixel_size ) + pixel_size + mill_width + x_offset
                y_cut = square_size - ( y_path[0] * pixel_size ) + mill_width + y_offset
                gcode_out.write("G1 X%(x)0.4f Y%(y)0.4f \n" % {'x': x_cut, 'y': y_cut})
            for i in range(1,len(x_path)):
                direction = dir_path[i]
                #move directions 1=right,2=down,3=left,4=up
                #clockwise cuts
                if direction == 1 and dir_path[i-1]==4:
                    x_cut = ( x_path[i] * pixel_size ) - mill_width  + x_offset
                    y_cut = square_size - ( y_path[i] * pixel_size ) + mill_width + y_offset
                    gcode_out.write("G1 X%(x)0.4f Y%(y)0.4f \n" % {'x': x_cut, 'y': y_cut})
                    gcode_out.write("G4 P%0.1f \n" % dwell_time)
                elif direction == 2 and dir_path[i-1]==1:
                    x_cut = ( x_path[i] * pixel_size ) + pixel_size + mill_width + x_offset
                    y_cut = square_size - ( y_path[i] * pixel_size ) + mill_width + y_offset
                    gcode_out.write("G1 X%(x)0.4f Y%(y)0.4f \n" % {'x': x_cut, 'y': y_cut})
                    gcode_out.write("G4 P%0.1f \n" % dwell_time)
                elif direction == 3 and dir_path[i-1]==2:
                    x_cut = ( x_path[i] * pixel_size ) + pixel_size + mill_width + x_offset
                    y_cut = square_size - ( y_path[i] * pixel_size ) - pixel_size - mill_width + y_offset
                    gcode_out.write("G1 X%(x)0.4f Y%(y)0.4f \n" % {'x': x_cut, 'y': y_cut})
                    gcode_out.write("G4 P%0.1f \n" % dwell_time)
                elif direction == 4 and dir_path[i-1]==3:
                    x_cut = ( x_path[i] * pixel_size ) - mill_width + x_offset
                    y_cut = square_size - ( y_path[i] * pixel_size ) - pixel_size - mill_width + y_offset
                    gcode_out.write("G1 X%(x)0.4f Y%(y)0.4f \n" % {'x': x_cut, 'y': y_cut})
                    gcode_out.write("G4 P%0.1f \n" % dwell_time)
                #anticlockwise cuts
                elif direction == 1 and dir_path[i-1]==2:
                    x_cut = ( x_path[i] * pixel_size ) + pixel_size + mill_width + x_offset
                    y_cut = square_size - ( y_path[i] * pixel_size ) + mill_width + y_offset
                    gcode_out.write("G1 X%(x)0.4f Y%(y)0.4f \n" % {'x': x_cut, 'y': y_cut})
                    gcode_out.write("G4 P%0.1f \n" % dwell_time)
                elif direction == 2 and dir_path[i-1]==3:
                    x_cut = ( x_path[i] * pixel_size ) + pixel_size + mill_width + x_offset
                    y_cut = square_size - ( y_path[i] * pixel_size ) - pixel_size - mill_width + y_offset
                    gcode_out.write("G1 X%(x)0.4f Y%(y)0.4f \n" % {'x': x_cut, 'y': y_cut})
                    gcode_out.write("G4 P%0.1f \n" % dwell_time)
                elif direction == 3 and dir_path[i-1]==4:
                    x_cut = ( x_path[i] * pixel_size ) - mill_width + x_offset
                    y_cut = square_size - ( y_path[i] * pixel_size ) - pixel_size - mill_width + y_offset
                    gcode_out.write("G1 X%(x)0.4f Y%(y)0.4f \n" % {'x': x_cut, 'y': y_cut})
                    gcode_out.write("G4 P%0.1f \n" % dwell_time)
                elif direction == 4 and dir_path[i-1]==1:
                    x_cut = ( x_path[i] * pixel_size ) - mill_width + x_offset
                    y_cut = square_size - ( y_path[i] * pixel_size ) + mill_width + y_offset
                    gcode_out.write("G1 X%(x)0.4f Y%(y)0.4f \n" % {'x': x_cut, 'y': y_cut})
                    gcode_out.write("G4 P%0.1f \n" % dwell_time)
                    
        if(engrave_depth%depth_per_pass==0):
            pass
        else:
            gcode_out.write("G1 Z-%0.4f \n" % engrave_depth)
            gcode_out.write("G4 P%0.1f \n" % dwell_time)
            #check if path going straight down first
            if dir_path[0] == 2:
                x_cut = ( x_path[0] * pixel_size ) + pixel_size + mill_width + x_offset
                y_cut = square_size - ( y_path[0] * pixel_size ) + mill_width + y_offset
                gcode_out.write("G1 X%(x)0.4f Y%(y)0.4f \n" % {'x': x_cut, 'y': y_cut})
            for i in range(1,len(x_path)):
                direction = dir_path[i]
                #move directions 1=right,2=down,3=left,4=up
                #clockwise cuts
                if direction == 1 and dir_path[i-1]==4:
                    x_cut = ( x_path[i] * pixel_size ) - mill_width  + x_offset
                    y_cut = square_size - ( y_path[i] * pixel_size ) + mill_width + y_offset
                    gcode_out.write("G1 X%(x)0.4f Y%(y)0.4f \n" % {'x': x_cut, 'y': y_cut})
                    gcode_out.write("G4 P%0.1f \n" % dwell_time)
                elif direction == 2 and dir_path[i-1]==1:
                    x_cut = ( x_path[i] * pixel_size ) + pixel_size + mill_width + x_offset
                    y_cut = square_size - ( y_path[i] * pixel_size ) + mill_width + y_offset
                    gcode_out.write("G1 X%(x)0.4f Y%(y)0.4f \n" % {'x': x_cut, 'y': y_cut})
                    gcode_out.write("G4 P%0.1f \n" % dwell_time)
                elif direction == 3 and dir_path[i-1]==2:
                    x_cut = ( x_path[i] * pixel_size ) + pixel_size + mill_width + x_offset
                    y_cut = square_size - ( y_path[i] * pixel_size ) - pixel_size - mill_width + y_offset
                    gcode_out.write("G1 X%(x)0.4f Y%(y)0.4f \n" % {'x': x_cut, 'y': y_cut})
                    gcode_out.write("G4 P%0.1f \n" % dwell_time)
                elif direction == 4 and dir_path[i-1]==3:
                    x_cut = ( x_path[i] * pixel_size ) - mill_width + x_offset
                    y_cut = square_size - ( y_path[i] * pixel_size ) - pixel_size - mill_width + y_offset
                    gcode_out.write("G1 X%(x)0.4f Y%(y)0.4f \n" % {'x': x_cut, 'y': y_cut})
                    gcode_out.write("G4 P%0.1f \n" % dwell_time)
                #anticlockwise cuts
                elif direction == 1 and dir_path[i-1]==2:
                    x_cut = ( x_path[i] * pixel_size ) + pixel_size + mill_width + x_offset
                    y_cut = square_size - ( y_path[i] * pixel_size ) + mill_width + y_offset
                    gcode_out.write("G1 X%(x)0.4f Y%(y)0.4f \n" % {'x': x_cut, 'y': y_cut})
                    gcode_out.write("G4 P%0.1f \n" % dwell_time)
                elif direction == 2 and dir_path[i-1]==3:
                    x_cut = ( x_path[i] * pixel_size ) + pixel_size + mill_width + x_offset
                    y_cut = square_size - ( y_path[i] * pixel_size ) - pixel_size - mill_width + y_offset
                    gcode_out.write("G1 X%(x)0.4f Y%(y)0.4f \n" % {'x': x_cut, 'y': y_cut})
                    gcode_out.write("G4 P%0.1f \n" % dwell_time)
                elif direction == 3 and dir_path[i-1]==4:
                    x_cut = ( x_path[i] * pixel_size ) - mill_width + x_offset
                    y_cut = square_size - ( y_path[i] * pixel_size ) - pixel_size - mill_width + y_offset
                    gcode_out.write("G1 X%(x)0.4f Y%(y)0.4f \n" % {'x': x_cut, 'y': y_cut})
                    gcode_out.write("G4 P%0.1f \n" % dwell_time)
                elif direction == 4 and dir_path[i-1]==1:
                    x_cut = ( x_path[i] * pixel_size ) - mill_width + x_offset
                    y_cut = square_size - ( y_path[i] * pixel_size ) + mill_width + y_offset
                    gcode_out.write("G1 X%(x)0.4f Y%(y)0.4f \n" % {'x': x_cut, 'y': y_cut})
                    gcode_out.write("G4 P%0.1f \n" % dwell_time)
           
    #lift cutter away
    gcode_out.write("G1 Z%0.4f \n" % clearance_height)


#####################
##Cut paths
#####################
    
def cut_path(gcode_out, x, y ):
    #Cut out following top path starting from top left corner 
    start_x = x
    start_y = y
    x_path = [start_x]
    y_path = [start_y]
    start_direction = 1
    move_x = start_x
    move_y = start_y

    #check if pixel not already in middle of paths
    if check_array[move_x][move_y+1]==True:
        check_array[move_x][move_y] = True
        return
    elif check_array[move_x][move_y-1]==True:
        check_array[move_x][move_y] = True
        return
    elif check_array[move_x+1][move_y]==True:
        check_array[move_x][move_y] = True
        return
    elif check_array[move_x-1][move_y]==True:
        check_array[move_x][move_y] = True
        return

        
    #move directions 1=right,2=down,3=left,4=up
    #take pixel check all 4 directions
    #####check starting direction
    #check starting direction
    if qrmatrix[start_y-1][start_x] == True:
        start_direction = 4
        move_y = start_y-1
    elif qrmatrix[start_y][start_x+1] == True:
        start_direction = 1
        move_x = start_x + 1
    elif qrmatrix[start_y + 1][start_x] == True:
        start_direction = 2
        move_y = start_y + 1
    elif qrmatrix[start_y][start_x - 1] == True:
        start_direction = 3
        move_x = start_x - 1
    dir_path=[start_direction]
    direction=start_direction
    continue_path = True
    while continue_path == True:
        check_array[move_x][move_y] = True   #check off already done pixels
        if (move_x==start_x) and (move_y==start_y) and (direction==start_direction):
                    continue_path = False
                    continue
        if direction==1:   #moving right   
            #check up
            test_x = move_x
            test_y = move_y - 1
            test_pixel = qrmatrix[test_y][test_x]
            if test_pixel==True:
                direction=4
                x_path.append(move_x)
                y_path.append(move_y)
                dir_path.append(4)
                if (move_x==start_x) and (move_y==start_y) and (direction==start_direction):
                    continue_path = False
                move_y = move_y - 1
                continue
            #move right 1
            test_x = move_x + 1
            test_y = move_y
            test_pixel = qrmatrix[test_y][test_x]
            if test_pixel==True:
                move_x = move_x + 1
                if (move_x==start_x) and (move_y==start_y) and (direction==start_direction):
                    continue_path = False
                continue
            #check down
            test_x = move_x
            test_y = move_y + 1
            test_pixel = qrmatrix[test_y][test_x]
            if test_pixel==True:
                direction=2
                x_path.append(move_x)
                y_path.append(move_y)
                dir_path.append(2)
                if (move_x==start_x) and (move_y==start_y) and (direction==start_direction):
                    continue_path = False
                move_y = move_y + 1
                continue
            #check left
            test_x = move_x - 1
            test_y = move_y
            test_pixel = qrmatrix[test_y][test_x]
            if test_pixel==True:
                direction=3
                x_path.append(move_x)
                y_path.append(move_y)
                dir_path.append(2)
                x_path.append(move_x)
                y_path.append(move_y)
                dir_path.append(3)
                if (move_x==start_x) and (move_y==start_y) and (direction==start_direction):
                    continue_path = False
                move_x = move_x - 1
                continue
        elif direction==2:  #moving down
            #check right
            test_x = move_x + 1
            test_y = move_y
            test_pixel = qrmatrix[test_y][test_x]
            if test_pixel==True:
                direction=1
                x_path.append(move_x)
                y_path.append(move_y)
                dir_path.append(1)
                if (move_x==start_x) and (move_y==start_y) and (direction==start_direction):
                    continue_path = False
                move_x = move_x + 1
                continue
            #move down 1
            test_x = move_x
            test_y = move_y + 1
            test_pixel = qrmatrix[test_y][test_x]
            if test_pixel==True:
                move_y = move_y + 1
                if (move_x==start_x) and (move_y==start_y) and (direction==start_direction):
                    continue_path = False
                continue
            #check left
            test_x = move_x - 1
            test_y = move_y
            test_pixel = qrmatrix[test_y][test_x]
            if test_pixel==True:
                direction=3
                x_path.append(move_x)
                y_path.append(move_y)
                dir_path.append(3)
                if (move_x==start_x) and (move_y==start_y) and (direction==start_direction):
                    continue_path = False
                move_x = move_x - 1
                continue
            #check up
            test_x = move_x
            test_y = move_y - 1
            test_pixel = qrmatrix[test_y][test_x]
            if test_pixel==True:
                direction=4
                x_path.append(move_x)
                y_path.append(move_y)
                dir_path.append(3)
                x_path.append(move_x)
                y_path.append(move_y)
                dir_path.append(4)
                if (move_x==start_x) and (move_y==start_y) and (direction==start_direction):
                    continue_path = False
                move_y = move_y - 1
                continue
        elif direction == 3:    #move left
            #check down
            test_x = move_x
            test_y = move_y + 1
            test_pixel = qrmatrix[test_y][test_x]
            if test_pixel==True:
                direction=2
                x_path.append(move_x)
                y_path.append(move_y)
                dir_path.append(2)
                if (move_x==start_x) and (move_y==start_y) and (direction==start_direction):
                    continue_path = False
                move_y = move_y + 1
                continue
            #move left 1
            test_x = move_x - 1
            test_y = move_y
            test_pixel = qrmatrix[test_y][test_x]
            if test_pixel==True:
                move_x = move_x - 1
                if (move_x==start_x) and (move_y==start_y) and (direction==start_direction):
                    continue_path = False
                continue
            #check up
            test_x = move_x
            test_y = move_y - 1
            test_pixel = qrmatrix[test_y][test_x]
            if test_pixel==True:
                direction=4
                x_path.append(move_x)
                y_path.append(move_y)
                dir_path.append(4)
                if (move_x==start_x) and (move_y==start_y) and (direction==start_direction):
                    continue_path = False
                move_y = move_y - 1
                continue
            #check right
            test_x = move_x + 1
            test_y = move_y
            test_pixel = qrmatrix[test_y][test_x]
            if test_pixel==True:
                direction=1
                x_path.append(move_x)
                y_path.append(move_y)
                dir_path.append(4)
                x_path.append(move_x)
                y_path.append(move_y)
                dir_path.append(1)
                if (move_x==start_x) and (move_y==start_y) and (direction==start_direction):
                    continue_path = False
                move_x = move_x + 1
                continue
        elif direction == 4: #move up
            #check left
            test_x = move_x - 1
            test_y = move_y
            test_pixel = qrmatrix[test_y][test_x]
            if test_pixel==True:
                direction=3
                x_path.append(move_x)
                y_path.append(move_y)
                dir_path.append(3)
                if (move_x==start_x) and (move_y==start_y) and (direction==start_direction):
                    continue_path = False
                move_x = move_x - 1
                continue
            #move up 1
            test_x = move_x
            test_y = move_y - 1
            test_pixel = qrmatrix[test_y][test_x]
            if test_pixel==True:
                move_y = move_y - 1
                if (move_x==start_x) and (move_y==start_y) and (direction==start_direction):
                    continue_path = False
                continue
            #check right
            test_x = move_x + 1
            test_y = move_y
            test_pixel = qrmatrix[test_y][test_x]
            if test_pixel==True:
                direction=1
                x_path.append(move_x)
                y_path.append(move_y)
                dir_path.append(1)
                if (move_x==start_x) and (move_y==start_y) and (direction==start_direction):
                    continue_path = False
                move_x = move_x + 1
                continue
            #check down
            test_x = move_x
            test_y = move_y + 1
            test_pixel = qrmatrix[test_y][test_x]
            if test_pixel==True:
                direction=2
                x_path.append(move_x)
                y_path.append(move_y)
                dir_path.append(1)
                x_path.append(move_x)
                y_path.append(move_y)
                dir_path.append(2)
                if (move_x==start_x) and (move_y==start_y) and (direction==start_direction):
                    continue_path = False
                move_y = move_y + 1
                continue
    
    #########################
    ##G-code for cutting path
    #########################

    #if single pixel do simple cut
    if len(x_path) == 1:
        x_start = (x_path[0] * pixel_size) + mill_width + x_offset
        y_start = square_size - (y_path[0] * pixel_size) - mill_width + y_offset
        x_end = (x_path[0]*pixel_size) + pixel_size - mill_width + x_offset
        y_end = square_size - (y_path[0] * pixel_size) - pixel_size + mill_width + y_offset
        gcode_out.write("G0 X%(x)0.4f Y%(y)0.4f \n" % {'x': x_start, 'y': y_start})
        #cut square
        cut_passes = int(engrave_depth / depth_per_pass)
        for cut_pass in range(0, cut_passes):
            pass_depth = (1 + cut_pass) * depth_per_pass
            gcode_out.write("G1 Z-%0.4f \n" % pass_depth)
            gcode_out.write("G4 P%0.1f \n" % dwell_time)
            gcode_out.write("G1 X%(x)0.4f Y%(y)0.4f \n" % {'x': x_end, 'y': y_start})
            gcode_out.write("G4 P%0.1f \n" % dwell_time)
            gcode_out.write("G1 X%(x)0.4f Y%(y)0.4f \n" % {'x': x_end, 'y': y_end})
            gcode_out.write("G4 P%0.1f \n" % dwell_time)
            gcode_out.write("G1 X%(x)0.4f Y%(y)0.4f \n" % {'x': x_start, 'y': y_end})
            gcode_out.write("G4 P%0.1f \n" % dwell_time)
            gcode_out.write("G1 X%(x)0.4f Y%(y)0.4f \n" % {'x': x_start, 'y': y_start})
            gcode_out.write("G4 P%0.1f \n" % dwell_time)
        if(engrave_depth%depth_per_pass==0):
            pass
        else:
            gcode_out.write("G1 Z-%0.4f \n" % engrave_depth)
            gcode_out.write("G4 P%0.1f \n" % dwell_time)
            gcode_out.write("G1 X%(x)0.4f Y%(y)0.4f \n" % {'x': x_end, 'y': y_start})
            gcode_out.write("G4 P%0.1f \n" % dwell_time)
            gcode_out.write("G1 X%(x)0.4f Y%(y)0.4f \n" % {'x': x_end, 'y': y_end})
            gcode_out.write("G4 P%0.1f \n" % dwell_time)
            gcode_out.write("G1 X%(x)0.4f Y%(y)0.4f \n" % {'x': x_start, 'y': y_end})
            gcode_out.write("G4 P%0.1f \n" % dwell_time)
            gcode_out.write("G1 X%(x)0.4f Y%(y)0.4f \n" % {'x': x_start, 'y': y_start}) 
            gcode_out.write("G4 P%0.1f \n" % dwell_time) 
    else:
        #start from top pixel and keep going down    
        x_cut = ( x_path[0] * pixel_size ) + mill_width + x_offset
        y_cut = square_size - ( y_path[0] * pixel_size ) - mill_width + y_offset
        #move to start point of path
        gcode_out.write("G0 X%(x)0.4f Y%(y)0.4f \n" % {'x': x_cut, 'y': y_cut})
        cut_passes = int(engrave_depth / depth_per_pass)
        for cut_pass in range(0, cut_passes):
            pass_depth = (1 + cut_pass) * depth_per_pass
            gcode_out.write("G1 Z-%0.4f \n" % pass_depth)
            gcode_out.write("G4 P%0.1f \n" % dwell_time)
            #check if path going straight down first
            if dir_path[0] == 2:
                x_cut = ( x_path[0] * pixel_size ) + pixel_size - mill_width + x_offset
                y_cut = square_size - ( y_path[0] * pixel_size ) - mill_width + y_offset
                gcode_out.write("G1 X%(x)0.4f Y%(y)0.4f \n" % {'x': x_cut, 'y': y_cut})
            for i in range(1,len(x_path)):
                direction = dir_path[i]
                #move directions 1=right,2=down,3=left,4=up
                #clockwise cuts
                if direction == 1 and dir_path[i-1]==4:
                    x_cut = ( x_path[i] * pixel_size ) + mill_width + x_offset
                    y_cut = square_size - ( y_path[i] * pixel_size ) - mill_width + y_offset
                    gcode_out.write("G1 X%(x)0.4f Y%(y)0.4f \n" % {'x': x_cut, 'y': y_cut})
                    gcode_out.write("G4 P%0.1f \n" % dwell_time)
                elif direction == 2 and dir_path[i-1]==1:
                    x_cut = ( x_path[i] * pixel_size ) + pixel_size - mill_width + x_offset
                    y_cut = square_size - ( y_path[i] * pixel_size ) - mill_width + y_offset
                    gcode_out.write("G1 X%(x)0.4f Y%(y)0.4f \n" % {'x': x_cut, 'y': y_cut})
                    gcode_out.write("G4 P%0.1f \n" % dwell_time)
                elif direction == 3 and dir_path[i-1]==2:
                    x_cut = ( x_path[i] * pixel_size ) + pixel_size - mill_width + x_offset
                    y_cut = square_size - ( y_path[i] * pixel_size ) - pixel_size + mill_width + y_offset
                    gcode_out.write("G1 X%(x)0.4f Y%(y)0.4f \n" % {'x': x_cut, 'y': y_cut})
                    gcode_out.write("G4 P%0.1f \n" % dwell_time)
                elif direction == 4 and dir_path[i-1]==3:
                    x_cut = ( x_path[i] * pixel_size ) + mill_width + x_offset
                    y_cut = square_size - ( y_path[i] * pixel_size ) - pixel_size + mill_width + y_offset
                    gcode_out.write("G1 X%(x)0.4f Y%(y)0.4f \n" % {'x': x_cut, 'y': y_cut})
                    gcode_out.write("G4 P%0.1f \n" % dwell_time)
                #anticlockwise cuts
                elif direction == 1 and dir_path[i-1]==2:
                    x_cut = ( x_path[i] * pixel_size ) + pixel_size - mill_width + x_offset
                    y_cut = square_size - ( y_path[i] * pixel_size ) - mill_width + y_offset
                    gcode_out.write("G1 X%(x)0.4f Y%(y)0.4f \n" % {'x': x_cut, 'y': y_cut})
                    gcode_out.write("G4 P%0.1f \n" % dwell_time)
                elif direction == 2 and dir_path[i-1]==3:
                    x_cut = ( x_path[i] * pixel_size ) + pixel_size - mill_width + x_offset
                    y_cut = square_size - ( y_path[i] * pixel_size ) - pixel_size + mill_width + y_offset
                    gcode_out.write("G1 X%(x)0.4f Y%(y)0.4f \n" % {'x': x_cut, 'y': y_cut})
                    gcode_out.write("G4 P%0.1f \n" % dwell_time)
                elif direction == 3 and dir_path[i-1]==4:
                    x_cut = ( x_path[i] * pixel_size ) + mill_width + x_offset
                    y_cut = square_size - ( y_path[i] * pixel_size ) - pixel_size + mill_width + y_offset
                    gcode_out.write("G1 X%(x)0.4f Y%(y)0.4f \n" % {'x': x_cut, 'y': y_cut})
                    gcode_out.write("G4 P%0.1f \n" % dwell_time)
                elif direction == 4 and dir_path[i-1]==1:
                    x_cut = ( x_path[i] * pixel_size ) + mill_width + x_offset
                    y_cut = square_size - ( y_path[i] * pixel_size ) - mill_width + y_offset
                    gcode_out.write("G1 X%(x)0.4f Y%(y)0.4f \n" % {'x': x_cut, 'y': y_cut})
                    gcode_out.write("G4 P%0.1f \n" % dwell_time)
        if(engrave_depth%depth_per_pass==0):
            pass
        else:
            gcode_out.write("G1 Z-%0.4f \n" % engrave_depth)
            gcode_out.write("G4 P%0.1f \n" % dwell_time)
            #check if path going straight down first
            if dir_path[0] == 2:
                x_cut = ( x_path[0] * pixel_size ) + pixel_size - mill_width + x_offset
                y_cut = square_size - ( y_path[0] * pixel_size ) - mill_width + y_offset
                gcode_out.write("G1 X%(x)0.4f Y%(y)0.4f \n" % {'x': x_cut, 'y': y_cut})
            for i in range(1,len(x_path)):
                direction = dir_path[i]
                #move directions 1=right,2=down,3=left,4=up
                #clockwise cuts
                if direction == 1 and dir_path[i-1]==4:
                    x_cut = ( x_path[i] * pixel_size ) + mill_width + x_offset 
                    y_cut = square_size - ( y_path[i] * pixel_size ) - mill_width + y_offset
                    gcode_out.write("G1 X%(x)0.4f Y%(y)0.4f \n" % {'x': x_cut, 'y': y_cut})
                    gcode_out.write("G4 P%0.1f \n" % dwell_time)
                elif direction == 2 and dir_path[i-1]==1:
                    x_cut = ( x_path[i] * pixel_size ) + pixel_size - mill_width + x_offset
                    y_cut = square_size - ( y_path[i] * pixel_size ) - mill_width + y_offset
                    gcode_out.write("G1 X%(x)0.4f Y%(y)0.4f \n" % {'x': x_cut, 'y': y_cut})
                    gcode_out.write("G4 P%0.1f \n" % dwell_time)
                elif direction == 3 and dir_path[i-1]==2:
                    x_cut = ( x_path[i] * pixel_size ) + pixel_size - mill_width + x_offset
                    y_cut = square_size - ( y_path[i] * pixel_size ) - pixel_size + mill_width + y_offset
                    gcode_out.write("G1 X%(x)0.4f Y%(y)0.4f \n" % {'x': x_cut, 'y': y_cut})
                    gcode_out.write("G4 P%0.1f \n" % dwell_time)
                elif direction == 4 and dir_path[i-1]==3:
                    x_cut = ( x_path[i] * pixel_size ) + mill_width + x_offset
                    y_cut = square_size - ( y_path[i] * pixel_size ) - pixel_size + mill_width + y_offset
                    gcode_out.write("G1 X%(x)0.4f Y%(y)0.4f \n" % {'x': x_cut, 'y': y_cut})
                    gcode_out.write("G4 P%0.1f \n" % dwell_time)
                #anticlockwise cuts
                elif direction == 1 and dir_path[i-1]==2:
                    x_cut = ( x_path[i] * pixel_size ) + pixel_size - mill_width + x_offset 
                    y_cut = square_size - ( y_path[i] * pixel_size ) - mill_width + y_offset
                    gcode_out.write("G1 X%(x)0.4f Y%(y)0.4f \n" % {'x': x_cut, 'y': y_cut})
                    gcode_out.write("G4 P%0.1f \n" % dwell_time)
                elif direction == 2 and dir_path[i-1]==3:
                    x_cut = ( x_path[i] * pixel_size ) + pixel_size - mill_width + x_offset
                    y_cut = square_size - ( y_path[i] * pixel_size ) - pixel_size + mill_width + y_offset
                    gcode_out.write("G1 X%(x)0.4f Y%(y)0.4f \n" % {'x': x_cut, 'y': y_cut})
                    gcode_out.write("G4 P%0.1f \n" % dwell_time)
                elif direction == 3 and dir_path[i-1]==4:
                    x_cut = ( x_path[i] * pixel_size ) + mill_width + x_offset
                    y_cut = square_size - ( y_path[i] * pixel_size ) - pixel_size + mill_width + y_offset
                    gcode_out.write("G1 X%(x)0.4f Y%(y)0.4f \n" % {'x': x_cut, 'y': y_cut})
                    gcode_out.write("G4 P%0.1f \n" % dwell_time)
                elif direction == 4 and dir_path[i-1]==1:
                    x_cut = ( x_path[i] * pixel_size ) + mill_width + x_offset
                    y_cut = square_size - ( y_path[i] * pixel_size ) - mill_width + y_offset
                    gcode_out.write("G1 X%(x)0.4f Y%(y)0.4f \n" % {'x': x_cut, 'y': y_cut})
                    gcode_out.write("G4 P%0.1f \n" % dwell_time)
           
    #lift cutter away
    gcode_out.write("G1 Z%0.4f \n" % clearance_height)


    
def build_island_array():
    #fill in all the outline white bits to identify islands
    #seed borders
    for i in range(len(island_array)):
        island_array[0][i] = False
        island_array[i][0] = False
        island_array[len(island_array)-1][i] = False
        island_array[i][len(island_array[0])-1] = False
    #make pass from top left
    for x in range(1,len(island_array)-1):
        for y in range(1,len(island_array)-1):
            #set true white and next to other border part
            if qrmatrix[y][x] == True:
                pass
            else:
                if island_array[x-1][y-1] == False:
                    island_array[x][y] = False
                elif island_array[x-1][y] == False:
                    island_array[x][y] = False
                elif island_array[x-1][y+1] == False:
                    island_array[x][y] = False
                elif island_array[x][y-1] == False:
                    island_array[x][y] = False
                elif island_array[x][y+1] == False:
                    island_array[x][y] = False
                elif island_array[x+1][y-1] == False:
                    island_array[x][y] = False
                elif island_array[x+1][y] == False:
                    island_array[x][y] = False
                elif island_array[x+1][y+1] == False:
                    island_array[x][y] = False
    #make second pass from bottom right
    for x in range(len(island_array)-1,1,-1):
        for y in range(len(island_array)-1,1,-1):
            #set true white and next to other border part
            if qrmatrix[y][x] == True:
                pass
            else:
                if island_array[x-1][y-1] == False:
                    island_array[x][y] = False
                elif island_array[x-1][y] == False:
                    island_array[x][y] = False
                elif island_array[x-1][y+1] == False:
                    island_array[x][y] = False
                elif island_array[x][y-1] == False:
                    island_array[x][y] = False
                elif island_array[x][y+1] == False:
                    island_array[x][y] = False
                elif island_array[x+1][y-1] == False:
                    island_array[x][y] = False
                elif island_array[x+1][y] == False:
                    island_array[x][y] = False
                elif island_array[x+1][y+1] == False:
                    island_array[x][y] = False
    #make third pass from top right
    for x in range(len(island_array)-1,1,-1):
        for y in range(1,len(island_array)-1):
            #set true white and next to other border part
            if qrmatrix[y][x] == True:
                pass
            else:
                if island_array[x-1][y-1] == False:
                    island_array[x][y] = False
                elif island_array[x-1][y] == False:
                    island_array[x][y] = False
                elif island_array[x-1][y+1] == False:
                    island_array[x][y] = False
                elif island_array[x][y-1] == False:
                    island_array[x][y] = False
                elif island_array[x][y+1] == False:
                    island_array[x][y] = False
                elif island_array[x+1][y-1] == False:
                    island_array[x][y] = False
                elif island_array[x+1][y] == False:
                    island_array[x][y] = False
                elif island_array[x+1][y+1] == False:
                    island_array[x][y] = False
    #make final pass from bottom left
    for x in range(1,len(island_array)-1):
        for y in range(len(island_array)-1,1,-1):
            #set true white and next to other border part
            if qrmatrix[y][x] == True:
                pass
            else:
                if island_array[x-1][y-1] == False:
                    island_array[x][y] = False
                elif island_array[x-1][y] == False:
                    island_array[x][y] = False
                elif island_array[x-1][y+1] == False:
                    island_array[x][y] = False
                elif island_array[x][y-1] == False:
                    island_array[x][y] = False
                elif island_array[x][y+1] == False:
                    island_array[x][y] = False
                elif island_array[x+1][y-1] == False:
                    island_array[x][y] = False
                elif island_array[x+1][y] == False:
                    island_array[x][y] = False
                elif island_array[x+1][y+1] == False:
                    island_array[x][y] = False      



    #fill in the black spots too
    for x in range(0,len(island_array)):
        for y in range(0,len(island_array)):
            #set true white and next to other border part
            if qrmatrix[y][x] == True:
                island_array[x][y] = False


def cut_horizontal(gcode_out, x, y):
    #scan across x to find how long to cut strips
    start_x = x
    x_test = start_x
    scan_end = False
    while scan_end == False:
        x_test = x_test + 1 
        x_check = qrmatrix[y][x_test]
        if x_check == False:
            end_x = x_test - 1
            scan_end = True
        else:
            check_array[x_test][y]=True

    #cut lines from start_x to end_x
    y_start = square_size - ( y * pixel_size ) - mill_width + y_offset
    x_start_cut = ( start_x * pixel_size ) + mill_width + x_offset
    x_end_cut = ( end_x * pixel_size ) + pixel_size - mill_width + x_offset

    #move to start point of path
    cut_passes = int(engrave_depth / depth_per_pass)
    for cut_pass in range(0, cut_passes):
        pass_depth = (1 + cut_pass) * depth_per_pass
        cut_lines = (pixel_size / mill_width - 1.0)
        for line_no in range(0, int(cut_lines)):
            y_cut = y_start - mill_width * line_no
            gcode_out.write("G0 X%(x)0.4f Y%(y)0.4f \n" % {'x': x_start_cut, 'y': y_cut})
            gcode_out.write("G1 Z-%0.4f \n" % pass_depth)
            gcode_out.write("G1 X%(x)0.4f Y%(y)0.4f \n" % {'x': x_end_cut, 'y': y_cut})
            gcode_out.write("G1 Z%0.4f \n" %clearance_height)
        #test if between top to bottom needs to be cut out too
        #if single pixel
        if start_x == end_x:
            if qrmatrix[y+1][start_x] == True:
                y_cut = square_size - ( (y + 1) * pixel_size) + y_offset
                gcode_out.write("G0 X%(x)0.4f Y%(y)0.4f \n" % {'x': x_start_cut, 'y': y_cut})
                gcode_out.write("G1 Z-%0.4f \n" % pass_depth)
                gcode_out.write("G1 X%(x)0.4f Y%(y)0.4f \n" % {'x': x_end_cut, 'y': y_cut})
                gcode_out.write("G1 Z%0.4f \n" %clearance_height)
                y_cut = square_size - ( (y + 1) * pixel_size) - mill_width / 2 + y_offset
                gcode_out.write("G0 X%(x)0.4f Y%(y)0.4f \n" % {'x': x_start_cut, 'y': y_cut})
                gcode_out.write("G1 Z-%0.4f \n" % pass_depth)
                gcode_out.write("G1 X%(x)0.4f Y%(y)0.4f \n" % {'x': x_end_cut, 'y': y_cut})
                gcode_out.write("G1 Z%0.4f \n" %clearance_height)
        else:
            #loop to find lines
            y_cut = square_size - ( (y + 1) * pixel_size) + y_offset
            start_state = False
            for border_find in range(start_x,end_x+1,1):
                if qrmatrix[y+1][border_find] == True:
                    if start_state == False: #start cutting
                        x_cut = ( border_find * pixel_size ) + mill_width + x_offset
                        gcode_out.write("G0 X%(x)0.4f Y%(y)0.4f \n" % {'x': x_cut, 'y': y_cut})
                        gcode_out.write("G1 Z-%0.4f \n" % pass_depth)
                        start_state = True
                else:
                    if start_state == True: #end cutting
                        x_cut = ( ( border_find - 1 ) * pixel_size ) + pixel_size - mill_width + x_offset
                        gcode_out.write("G1 X%(x)0.4f Y%(y)0.4f \n" % {'x': x_cut, 'y': y_cut})
                        gcode_out.write("G1 Z%0.4f \n" %clearance_height)
                        start_state = False
            #if cutting still going
            if start_state == True:
                x_cut = ( ( border_find ) * pixel_size ) + pixel_size - mill_width + x_offset
                gcode_out.write("G1 X%(x)0.4f Y%(y)0.4f \n" % {'x': x_cut, 'y': y_cut})
                gcode_out.write("G1 Z%0.4f \n" %clearance_height)



    if(engrave_depth % depth_per_pass == 0):
        cut_lines = (pixel_size / mill_width - 1.0)
        for line_no in range(0, int(cut_lines)):
            y_cut = y_start - mill_width * line_no
            gcode_out.write("G0 X%(x)0.4f Y%(y)0.4f \n" % {'x': x_start_cut, 'y': y_cut})
            gcode_out.write("G1 Z-%0.4f \n" % engrave_depth)
            gcode_out.write("G1 X%(x)0.4f Y%(y)0.4f \n" % {'x': x_end_cut, 'y': y_cut})
            gcode_out.write("G1 Z%0.4f \n" %clearance_height)
        #test if between top to bottom needs to be cut out too
        #if single pixel
        if start_x == end_x:
            if qrmatrix[y+1][start_x] == True:
                y_cut = square_size - ( (y + 1) * pixel_size) + y_offset
                gcode_out.write("G0 X%(x)0.4f Y%(y)0.4f \n" % {'x': x_start_cut, 'y': y_cut})
                gcode_out.write("G1 Z-%0.4f \n" % engrave_depth)
                gcode_out.write("G1 X%(x)0.4f Y%(y)0.4f \n" % {'x': x_end_cut, 'y': y_cut})
                gcode_out.write("G1 Z%0.4f \n" %clearance_height)
                y_cut = square_size - ( (y + 1) * pixel_size) - mill_width / 2 + y_offset
                gcode_out.write("G0 X%(x)0.4f Y%(y)0.4f \n" % {'x': x_start_cut, 'y': y_cut})
                gcode_out.write("G1 Z-%0.4f \n" % engrave_depth)
                gcode_out.write("G1 X%(x)0.4f Y%(y)0.4f \n" % {'x': x_end_cut, 'y': y_cut})
                gcode_out.write("G1 Z%0.4f \n" %clearance_height)
        else:
            #loop to find lines
            y_cut = square_size - ( (y + 1) * pixel_size) + y_offset
            start_state = False
            for border_find in range(start_x,end_x+1,1):
                if qrmatrix[y+1][border_find] == True:
                    if start_state == False: #start cutting
                        x_cut = ( border_find * pixel_size ) + mill_width + x_offset
                        gcode_out.write("G0 X%(x)0.4f Y%(y)0.4f \n" % {'x': x_cut, 'y': y_cut})
                        gcode_out.write("G1 Z-%0.4f \n" % engrave_depth)
                        start_state = True
                else:
                    if start_state == True: #end cutting
                        x_cut = ( ( border_find - 1 ) * pixel_size ) + pixel_size - mill_width + x_offset
                        gcode_out.write("G1 X%(x)0.4f Y%(y)0.4f \n" % {'x': x_cut, 'y': y_cut})
                        gcode_out.write("G1 Z%0.4f \n" %clearance_height)
                        start_state = False
            #if cutting still going
            if start_state == True:
                x_cut = ( ( border_find ) * pixel_size ) + pixel_size - mill_width + x_offset
                gcode_out.write("G1 X%(x)0.4f Y%(y)0.4f \n" % {'x': x_cut, 'y': y_cut})
                gcode_out.write("G1 Z%0.4f \n" %clearance_height)
    else:
        pass
                  

    #lift cutter away
    gcode_out.write("G1 Z%0.4f \n" % clearance_height)
    
if __name__ == '__main__':
    main()

